# -*- coding: utf-8 -*-            
# @Author : Chen_jia_wei
# @Time : 2023/6/13 20:37

"""
深拷贝、浅拷贝 分别是什么，怎么使用？



"""
import copy

a = 100
b = a

# 关于a

print("数据类型： ", type(a))
print("唯一表示： ", id(a))
print("数据成员： ", dir(a))
print("是否调用： ", callable(a.from_bytes))  # 可能是方法（需要调用），也可能是属性（不需要调用）
print("方法的用法：", help(a.from_bytes))  # 可能是方法（需要调用），也可能是属性（不需要调用）

print("-" * 150)

# 关于b
print("数据类型： ", type(b))
print("唯一表示： ", id(b))
print("数据成员： ", dir(b))
print("是否调用： ", callable(b.from_bytes))  # 可能是方法（需要调用），也可能是属性（不需要调用）
print("方法的用法：", help(b.from_bytes))  # 可能是方法（需要调用），也可能是属性（不需要调用）

print("-" * 200)
if id(a) == id(b):
    print("a 和 b 是同一个对象")
print("-" * 150)
if a is b:
    print("a 和 b 是同一个对象")  # 内存地址 ， 是相同的
print("-" * 150)
if a == b:
    print("a 和 b 的值 是相等的")  # 内存地址中的值 ， 是相同的
print("-" * 150)

"""
可变对象，与 不可变对象
可变对象：
    除ID之外，其他状态都有可能发生改变
    
# 可变对象
l = []
print("修改前id= ", id(l))

l.append(132)
print("修改后id= ", id(l))
print(l)
    
不可变对象：
包括id在内的各种状态，都不会发生变化

# 不可变对象
i = 123
print("修改前id= ", id(i))

i = 456
print("修改后id= ", id(i))
print(i)
"""

# 可变对象
# 可变对象：列表、集合、字典
l = []
print("修改前id= ", id(l))

l.append(132)
print("修改后id= ", id(l))
print(l)

print("***" * 50)

# 不可变对象
# 大部分是python内置数据类型： 数字，字符串，元组
i = 123
print("修改前id= ", id(i))

i = 456
print("修改后id= ", id(i))  # id 变化了，说明数据的修改不是建立在原内存的， 而是新申请了内存，保存新的值
print(i)
print("***" * 50)

# 特殊情况： 虽然也会创建新的对象，但是原对象没有发生变化
# 对于可变对象来说，也不一定每一次的修改都是在 原内存空间进行的

"""/3、为什么要使用不可变对象？
    函数式编程对象: 函数第一、***不可变数据***、尾递归、柯里化
    字典的 key 必须是不可变的，可哈希的,字典是个mapping 必须保持不变
    复用 相同的数据，可以提高效率

"""

l = [1, 2, 3]
_id = id(l)
d = {}
d[id(l)] = "cjw"
l.append(4)
print(d[id(l)])
print(l)

"""

4、数据类型转换
Python 中的数据类型，一定不是原内存进行修改
实际上是创建新的对象，这意味使用新的 内存地址

"""
print("*"* 200)
a = "1111"
l = list(a)
ll = tuple(a)
lll = set(a)
llll = str(a)   # 新的字符串，字符串属于不可变对象 0-1000数字整数复用空间
print(type(a),id(a))
print(type(l),id(l))
print(type(ll),id(ll))
print(type(lll),id(lll))
print(type(llll),id(llll))
"""
如果id 没变，说明数据可变
如果id 变了，说明数据不可变

id 是指数据 内存的地址
"""
print("*"* 200)
"""
5/ 深拷贝 和 浅拷贝

拷贝是赋值一份数据，
    
对于不可变对象（数字、字符串）拷贝会不会申请新的内存？
    不会，重复使用内存中的数字、字符串，不可以拷贝

深拷贝 和 浅拷贝  ，只针对于可变对象
拷贝是赋值一份数据

=: 是指赋值，讲符号左右的变量名指向数据
拷贝L创建了一份一样的数据
l = []
ll = l 是赋值  ，指ll 指向 l 的内存地址
赋值 不会创建对象，不会去申请内存地址    


"""
l = []
ll = l
print("l id",id(l))
print("ll id",id(ll))
print("*"* 200)





# 五：浅拷贝详解
"""
浅拷贝做两件事：
1、为*目标对象*创建副本
2、将*副本对象*的成员，指向“目标对象”的成员
只为对象开辟了内存，没有对 对象的成员创建新的内存
"""
d = {
    "l":[],
    "ll":123
}
l = copy.copy(d)  # 没有创建数据 ， l 是新的内存地址
# l 是新的字典，拥有和d一样的成员
print(id(l),type(l))
print(id(d),type(d))

# 浅拷贝的意义：
# 为浅拷贝的对象创建了新内存地址，没有对对象成员开辟新的内存地址，增强了复用性；

print("*"* 200)


print("*"* 200)
# 六：深拷贝详解：
"""
深拷贝做了三件事：
为“目标对象”创建副本（开辟内存）
为目标对象的成员“创建副本”，以及成员的对象（开辟内存）
将“副本对象”的成员，指向新创建的副本成员

"""


print("*"* 200)

# 什么情况下用到：

# 深拷贝：完整的复制一份数据，以期望原数据的修改，不会对副本产生影响
# 该有的全部 备份了，弊端：成本比较高

# 浅拷贝：
# 只复制目标，而不复制目标的成员，低沉本完成目标的复制
# 只是复制了一个空壳


print("*"* 200)